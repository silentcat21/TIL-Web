<!DOCTYPE html>
<html>
<body>
<!--CSS 크기 단위
    1. px
        픽셀(화소) 단위, 해상도에 따라 상대적인 크기를 가짐
    2. %(퍼센트)
        백분율 단위의 상대 단위, 지정 사이즈를 기반으로 상대적인 비율의 크기를 가짐
    3. em
        배수 단위, 지정 사이즈를 기반으로 배수로 계산된 크기를 가짐
        중첩된 자식 요소에 em을 지정하면 모든 자식 요소 사이즈에 영향을 주므로 주의해야 함
    4. rem
        em과 달리 rem은 root em으로, 최상위 요소(html, default: 16px) 사이즈를 기준으로 함
    
    https://codesandbox.io/s/cssdanwi-u2g72?file=/index.html
 -->   
<!--Viewport 단위
    1. vw: viewport 너비의 1/100 (1%)
    2. vh: viewport 높이의 1/100 (1%)
    3. vmin: viewport 너비 또는 높이 중 작은 쪽의 1/100(1%)
    4. vmax: viewport 너비 또는 높이 중 큰 쪽의 1/100(1%) 
    간단히 퍼센트라고 이해하면 됨(최대값 100)   

    https://codesandbox.io/s/cssviewport-x2qrx?file=/index.html

    색상 표현 단위
    색상 표현을 위한 다양한 표기 방법이 존재함
    1. 색상 이름으로 표기하는 방법: 주요 색상 이름 참고(https://www.w3schools.com/colors/colors_names.asp)
    2. 16진수 표기 방법 (HEX 코드(Hexadecimal Colors)): 예, #ffffff
    3. RGB(Red, Green, Blue)표기 방법: 예, rgb(138, 43, 226)
    4. RGBA(Red, Green, Blue, Alpha/투명도)표기 방법: rgba(138, 43, 226, 0.5)

    색상 참고 사이트(https://material.io/design/color/the-color-system.html#tools-for-picking-colors, https://color.adobe.com/ko/explore)

    참고: RGBA 와 opacity 프로퍼티 차이점
            -opacity 프로퍼티: 투명도 설정, 0.0이 완전 투명, 1.0이 완전 불투명
            -opacity 프로퍼티 값은 모든 자식 요소에 투명도 값이 상속됨
            -반면에, RGBA 값으로 설정하면, 상속되지 않음

            상속이란? 태그 간 부모/자식 관계에 따라, 부모의 CSS 프로퍼티 값이 자식 태그에도 적용되는 경우를 이야기함
            css 프로퍼티에 따라 상속이 되거나, 안되는 프로퍼티가 존재함
    
    
    CSS Selector
        IT 기술은 서로 연결되어 있습니다.
        CSS Selector는 CSS 문법 중 하나이며, 이를 크롤링 관련 기술에서 활용하고 있는 것입니다
            -HTML 문서의 특정 부분에 대해 렌더링 방법을 정의하기 위해서는 특정 부분을 선택할 수 있어야 함
            -CSS Selector는 이런 특정 부분을 선택하기 위한 문법
            -CSS Selector로 HTML 문서 특정 부분을 정의한 구문을 Rule Set 이라고 부르며, 이와 같은 Rule Set 집합을
             Style Sheet라고 부름
        
        1. 전체 selector
         - * : HTML 문서 전체를 선택
                <style>
                    * { color: black; }
                </style>
        
        2. 태그 selector
         - 태그명으로 선택
                <style>
                    h1 {color: red;}
                </style>
        
        3. ID selector
         - #아이디명으로 선택(#을 앞에 붙여야 아이디인지를 구분할 수 있음)
                <style>
                    #sang { color: blue; }
                </style>
                <body>
                    <h1 id='sang'>hello</h1>
                </body>
        
        4. Class selector
         - .클래스명으로 선택(. 을 앞에 붙여야 아이디인지를 구분할 수 있음)
                <style>
                    .sang { color: green; }
                </style>
                <h1 class='sang'>hello</h1>
        
        5. Attribute (속성) selector
         - 각 문법 하단부 css 코드를 기반으로 설명해야, 이해할 수 있으므로, 이를 기반으로 설명
          - [속성]: attr 속성을 가지는 모든 태그(요소)
                <style> [attr] { color: red; }</style>
        
          - [속성=값]: attr 속성값이 정확히 속성을 가지는 모든 태그(요소), 대소문자 구분하지 않음
                <style> [attr="value"] { color: red; }</style>
          
          - [속성~=값]: attr 속성값이 "value"를 (공백으로 분리된) 단어로 포함되는 모든 태그, 대소문자 구분하지 않음
                <style> [attr~="value"] { color: red; }</style>
                    <h1 attr="value hello">hello</h1>

          - a[속성^=값]: a 태그의 요소 중 attr 속성의 값이 "value"로 시작하는 모든 태그. 대소문자 구분
                <style> a[attr^="value"] { color: red; }</style>
        
          - a[속성$=값]: a 태그의 요소 중 attr 속성의 값이 "value"로 끝나는 모든 태그. 대소문자 구분
                <style> a[attr$="value"] { color: red; }</style>
          
          - a[속성*=값]: a 태그의 요소 중 attr 속성의 값이 "value"를 포함하는 모든 태그. 대소문자 구분
                <style> a[attr*="value"] { color: red; }</style>
                언젠가는 힘들때도 있는데..
        5. 다양한 CSS selector 조합
          - 태그, 아이디, 클래스 selector를 조합해서 복합적으로 사용 가능
          - HTML 문서 특정 태그에 여러 클래스가 지정될 경우, 다음과 같이 스페이스를 이용해서 여러 클래스를 설정 할 수 있음
                class='클래스명 클래스명2 클래스명3'
                이 경우 css selector는 .클래스명1.클래스명2.클래스명3 와 같이 사용 가능
                이후부터는 하나의 태그로 이루어진 selector 부터, 여러 조합으로 붙여진 selector도 하나의 selector로 이해하기로 함
        6. 복합 selector(Combinator)
          - 태그 안에, 또 다른 태그를 넣을 수 있으므로, 각 태그 또는 요소 간에 부모/자식 관계가 매겨짐
          - 관계를 기반으로 HTML 문서 특정 부분을 선택할 수 있는 문법 
          - 후손 셀렉터 (Descendant selector): 스페이스로 표시
          - 자식 셀렉터 (Child Selector): >로 표시
          - 인접 형제 셀렉터 (Adjacent Sibling Selector): +로 표시
          - 일반 형제 셀렉터 (General Sibling Selector): ~로 표시

        6.1 후손 셀렉터: 스페이스로 표시
          - 부모 태그 안에 있는 모든 하위 태그를 하위 요소, 후손 요소라고 부름
          - 부모 태그(selector1) 안에 있는 모든 태그 중에 selector2를 선택
                selector1 selector2 (https://codesandbox.io/s/cssselectorhuson-nmzhi?file=/index.html)
        
        6.2 자식 셀렉터: >로 표시
          - 부모 태그 안에 있는 바로 다음 레벨의 태그(만 적용) 중에 selector2를 선택
                selector1 > selector2 ()
        
        6.3 인접 형제 셀렉터: +로 표시
          - 태그와 동일 레벨에 위치하고, selector1의 바로 뒤에 위치하는 selector2를 선택
                즉, selector1과 selector2 사이에 다른 태그 위치시 선택 안됨
                selector1 + selector2 (https://codesandbox.io/s/css-sibling-selector-t55pw?file=/index.html)

        6.4 일반 형제 셀렉터: ~로 표시
          - 태그1와 동일 레벨에 위치하고, 태그1의 뒤에 위치하는 태그2를 선택
                즉, 태그1과 태그2 사이에 다른 태그가 위치해도 선택 가능
                selector ~ selector2
        
        7. 가상 클래스 셀렉터(Pseudo-Class Selector)
          - 가상 클래스는 요소에 특정 이벤트 발생시를 선택하는 문법
          - 예: h1 태그 요소에 마우스가 올라갔을 때
        
        7.1 가상 클래스 종류
          -link: 방문하지 않은 링크가 적용된 요소(예: a 태그로 링크가 적용된 요소를 한 번도 클릭하지 않은 경우)
          -visited: 방문한 링크가 적용된 요소(예: a 태그로 링크가 적용된 요소를 한 번이라도 클릭한 경우)
          -hover: 특정 요소에 마우스가 올라간 상태
          -active: 링크 요소를 클릭한 상태(예: a 태그로 링크가 적용된 요소를 마우스로 클릭하고 있는(누르고 있는) 상태)
          -focus: 특정 요소에 포커스가 있는 상태(예: input 태그에 포커스가 있어서, 해당 입력창에 커서가 깜빡이는 상태)

          가상 셀렉터는 가상 요소 셀렉터 이외에는 한개의 콜론(:)을 사용함 (https://drive.google.com/drive/folders/1XNGSltJrqQXPwYqKh8EJU4-Zt3egxAE9)

        7.2 UI 요소 상태 셀렉터, 특정 UI요소 상태에 따른 셀렉터
          - enabled: UI 셀렉터가 사용 가능한 상태
          - disabled: UI 셀렉터가 사용 불가능한 상태
          - checked: UI 셀렉터가 체크된 상태
          - indeterminate: UI 셀렉터 상태가 결정되지 않은 상태(예: 체크박스에 체크가 안되었거나, 라디오 버튼들이 하나도 체크되지 않은 상태)
                (https://codesandbox.io/s/css-ui-element-pseudo-class-selector-mecrs?file=/index.html)
        
        7.3 구조 가상 클래스 셀렉터(Structured Pseudo-Class)
          - first-child: 부모의 첫 번째 자식인 요소 선택
          - last-child: 부모의 마지막 자식인 요소 선택
          - nth-child(n): 부모의 첫 번째 자식 요소부터 시작해서 n번째 요소 선택(0이 아니라, 1이 첫 번째 요소)
          - nth-last-child(n): 부모의 마지막 자식 요소부터 뒤에서 시작해서 n번째 요소 선택(0이 아니라, 1이 첫 번째 요소)
          - n은 1부터 시작, 2n은 짝수, 2n-1은 홀수와 같이 수식으로 표현가능(숫자로 일일이 지정할 필요가 없음)
          - first-of-type: 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중에 셀렉터에 해당하는 요소만 뽑아서, 이 중에 첫번째 요소
          - last-of-type: 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중에 셀렉터에 해당하는 요소만 뽑아서, 이 중에 마지막 요소
          - nth-of-type(n): 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중에 셀렉터에 해당하는 요소만 뽑아서, 이 중에 앞에서부터 n번째 요소
          - nth-last-of-type(n): 셀렉터에 해당하는 요소의 부모 요소의 자식 요소 중에 셀렉터에 해당하는 요소만 뽑아서, 이 중에 뒤에서부터 n번째 요소
        
        7.4 부정 셀렉터
          - not(셀렉터)- 셀렉터에 해당하지 않는 모든 요소 선택
        
        7.5 정합성 체크 셀렉터
          - valid(셀렉터): 정합성이 검증된 input 또는 form 요소 선택
          - invalid(셀렉터): 정합성 검증이 실패한 input 또는 form 요소 선택
                input 태그 유효성 검사와 정합성 체크 셀렉터
                - 정합성 체크 셀렉터 이해와 활용을 위해, input 태그의 유효성 검사 관련 속성을 이해해야 함
                - 다양한 속성이 있지만, 크로스 브라우저를 위해, 호환성이 떨어지는 속성은 사용하지 않는 편이 좋기 때문에, 호환성이 높은 속성만 정리

                1. required 속성
                - input 태그로 생성된 입력창에 데이터를 무조건 넣어야 함(데이터가 입력창에 들어가야 정합성이 검증됬다고 판단)
                2. pattern 속성
                - input 태그로 생성된 입력창에 넣은 데이터가 원하는 데이터 포맷에 맞으면 정합성이 검증됬다고 판단함
                - pattern 값은 정규표현식
                일반적으로 웹에서 input 창에 필요한 데이터 포맷은 이메일, 특수문자를 포함하는 패스워드 등 몇 가지로 추릴 수 있으며, 관련 정보를 웹에서 찾아보는 편이 좋음
                (http://www.w3bai.com/ko/tags/att_input_pattern.html)
        
        8. 가상 요소 셀렉터
          - 선택한 요소 안의 특정 부분을 선택(예: 특정 요소의 첫 글자, 마지막 글자 등)
          - first-letter: 요소의 첫 글자 선택
          - first-line: 요소의 첫 라인(줄) 선택(주의: block 요소에만 적용 가능, block/inline 요소느느 별도 챕터에서 설명)
          - after: 요소의 뒤에 위치하는 공간 선택, content 프로퍼티와 함께 사용
          - before: 요소의 앞에 위치하는 공간 선택, content 프로퍼티와 함께 사용
          - selection: 요소에서 드래그한 부분을 선택, iOS Safari 에서는 호환 안될 수도 있음
          다른 가상 셀렉터와 달리 두개의 콜론(::)을 사용

    */
-->
</body>
</html>